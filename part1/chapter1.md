## 1章 知識を噛み砕く

ドメインを理解し、モデルを作り上げていく過程の話(著者の実体験)
- 効果的なモデリングの方法 (ドメインの知識をいかにモデルに反映させていくか)
- モデルの利点

---

- プリント基板設計用の専門ソフトウェアツールの設計で行われた会話の例
- ドメインエキスパートと開発者が会話を通してモデルを作り上げる
- 初期のモデルをプロトタイプに落とし、ドメインエキスパートに示すことでモデルがソフトウェアにどう関係するのかを理解させることができた
- モデルを改良すると、コードも一緒に進化し機能の豊富なツールを手に入れることができた

---
### 効果的なモデリングに必要な要素

- モデルと実装を結び付ける
    - プロトタイピングによって本質的な結びつきが早い時期に作り出され、それが以後のイテレーションを通してずっと維持された
- モデルに基づいて言語を洗練させる
    - プロジェクトが進むにつれてモデルから用語を**そのまま取り出し**モデルの構造と矛盾しない文章にまとめて、通訳しなくても正確に理解し合えるようになった
- 知識豊富なモデルを開発する
    - **モデルとは単なるデータスキーマではない**
    - モデルは様々な種類の知識(ドメインの)が含まれている
- モデルを蒸留する
    - モデルが完成するに連れて**重要な概念が追加され、不要な概念が取り除かれていく**
    - 不要な概念と必要な概念が結びついてる時は本質的な概念を切り分け、不要なものを削除した新たなモデルを探す
- ブレインストーミングと実験を行う
    - 言語・スケッチ・ブレストを組み合わせることで、議論の場がモデルの実験室に変わる
    - 表現が明確でわかりやすいか、それともぎこちないかを聞いて察知することができる

これらを行うことで**知識の噛み砕き**が行われ、知識を価値のあるモデルへ変えることが出来る

---
### 知識の噛み砕き

有能なドメインモデラは知識を噛み砕く
- 大部分の意味を理解できるシンプルな見方を見つけようとする
- 多くのモデルが試され、却下され、変更され蒸留していく

知識の噛み砕く作業
- チームが共同で行う
- 様々な情報(ドキュメント・話し合い...etc)を噛み砕、役に立つ形にする

実装からのフィードバック
- 初期バージョン・プロトタイプの経験による**フィードバックにより解釈が変わっていく**
- 一方向ではなく、実装からのフィードバックがあるというのが**重要**
- ウォータフォールのような旧来手法ではモデルがうまく機能しない一因は実装からのフィードバックがないから

知識の噛み砕きを通して作られたモデル
- ビジネスに関する深い知識が反映されている
- モデルは綺麗に構成され、抽象化され実装に役立つ

モデルは情報を体系化するためのツール
- モデルは要件を分析することに焦点を合わせているがプログラミングや設計と深く相互作用する
- モデルの理解を通してドメインに対する洞察が深まり、モデルがさらに精緻化される

<!-- ---
### 継続的学習

知識の断片化
- プロジェクトの知識は多くの人やドキュメントの間に散財し、どの知識が本当に必要なのかもわからない
- 典型的なアプローチではコードやドキュメントは**知識**を伝えないため人の移動により知識は失われる

継続的学習の実践
- 自分達の知識を意識的に育てて、継続的学習を実施する
- ドメインモデリングのスキルや技術的な知識の向上を行いつつも、取り組んでいるドメインについて真剣に学習する -->

---
### 知識豊富な設計

モデルによって捉えらえる知識
- ドメインに現れる名詞(エンティティ)を見つけることだけではない
- ビジネスの活動やルールも含まれている

モデルの変化
- 変化したモデルを表現するように実装をリファクタリング
- 新しい知識をアプリケーションで利用できるようになる

---
#### 予約アプリケーションの例

ある船の一回の航海に対して、貨物を運んでもらうように予約するアプリケーション
- 貨物(Cargo)を航海(Voyage)と関連づけ、その関係を記録し追跡する責務を負う

```
    [航海] --------* [貨物]
```

```
public int makeBooking(Cargo cargo, Voyage voyage) {
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

輸送業界で標準的な慣習としてある「オーバーブッキング」(船舶が運搬できる量より多く貨物を受け付ける)をアプリケーションで扱えるようにする。

```
    10%のオーバーブッキングを認める
```

```
    |-----|           |-----|
    | 航海 | --------* | 貨物 |
    |-----|           |-----|
    |積載量|           |サイズ|
    |-----|           |-----|
```

```
public int makeBooking(Cargo cargo, Voyage voyage) {

    //-------------------------added---------------------------
    // 最大予約 = 航海の積載量 x 1.1
    double maxBooking = voyage.capacity() * 1.1
    if ((voyage.bookedCargoSize() + cargo.size()) > maxBooking)
        return -1;
    //---------------------------------------------------------
    
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

- ドメインエキスパートがコードを読んで、ルールが正しいかどうかを検証できない
- ビジネスについて知らない技術者が要求定義書の記述をコードと結びつけることが困難

知識をより適切に捉えられる設計に変更する
- オーバーブッキングというルールをポリシーと捉える
- ストラテジーと呼ばれるデザインパターンを適用しポリシーという概念を明確に表現する


```
    |-----|           |-----|
    | 航海 | --------* | 貨物 |
    |-----|     ^     |-----|
    |積載量|     |     |サイズ|
    |-----|     |     |-----|
    　　　　　　　｜
    　　　　　　　｜
    　　　　　　　｜
    　　　　　　　｜
    　[オーバーブッキングポリシー]
```

```
public int makeBooking(Cargo cargo, Voyage voyage) {

    //-------------------------modified---------------------------
    if (!overbookingPolicy.isAllowed(cargo, voyage)) return -1;
    //---------------------------------------------------------
    
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

オーバーブッキングポリシーのメソッド
```
public boolean isAllowed(Cargo cargo, Voyage voyage) {
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity()* 1.1);
}
```

オーバーブッキングというポリシーが存在することが明確

※ **こうした手の込んだ設計をドメインのあらゆる詳細に適用することを推奨してるわけではない**

明示的な設計の利点
- 誰もがオーバーブッキングの本質を明確で重要なビジネスルールだと理解する
- 成果物をドメインエキスパートが理解でき、フィードバックループを作ることができる

---
### 深いモデル

有用で明確なモデル
- 役立つモデルはすぐに見つかることは滅多にない
- 多くの場合は重要と思われたモデル要素を廃棄したり違った視点で見ることで問題の核心をつくような、うまい抽象が現れてくる
- ドメインの理解やモデリングテクニックの洗練が求められる
