# 本の目次

1部 ドメインモデルを機能させる

  1. 知識を噛み砕く 
  2. コミュニケーションとの言語の使い方
  3. モデルと実装を結びつける


2部 モデル駆動設計の構成要素

  4. ドメインを隔離する
  5. ソフトウェアで表現されたモデル
  6. ドメインオブジェクトのライフサイクル
  7. 言語をしようする: 応用例


3部 より深い洞察へ向かうリファクタリング

  8. ブレイクスルー
  9. 暗黙的な概念を明示的にする
  10. 視野なかな設計
  11. アナリシスパターンを適用する
  12. デザインパターンをモデルに関係づける
  13. より深い洞察へ向かうリファクタリング

4部 戦略的設計

  14. モデルの整合性を維持する
  15. 蒸留
  16. 大規模な構造
  17. 戦略をまとめ上げる

# 今日のアジェンダ
- はじめに
    - ドメイン駆動設計
    - この本が提供するもの
- ドメインモデルを機能させる
    - モデル
    - ドメイン
    - モデルはなぜ必要なのか?
    - 適切なモデルとは
- ドメイン駆動設計におけるモデルの有用性
- ソフトウェアの核心
- 知識を噛み砕く
    - 効果的なモデリングの要素
    - 知識の噛み砕き
    - 継続的学習
    - 知識豊富な設計
    - 深いモデル


# はじめに

## ドメイン駆動設計
- オブジェクトコミュニティの中で出現してきたある哲学を著者がまとめ上げ定義した
- 著者が携わったプロジェクトの中で成功したものに共通する特徴には豊かなドメインモデルがあり、設計のイテレーションを通じて進化しながら、プロジェクトの基礎の一部となっていた

## この本が提供するもの
- 設計上の意思決定を行うためのフレームワーク
- ドメイン設計について議論するための技術的な語彙

これらを利用することでドメイン駆動設計に体系的に取り組める

# 第1部　ドメインモデルを機能させる

モデル
- 現実の何らかの側面や興味の対象となる概念を表している
- 問題を解決する上で関連する側面を抽象化し、それ以外の詳細を無視する(簡素化)ことによって行われる１つの解釈

ドメイン
- ユーザがプログラムを適用する対象領域 (例) 会計プログラムのドメインは金銭と財務

モデルの必要性
- ユーザの活動において有効利用されるソフトウェアを作るためにドメインの体系化された知識を身につけなければならない
- ソフトウェア開発においてモデルはドメインの複雑さ・情報の量と格闘するためのツールとなりえる

適切なモデルとは
- 選び抜かれてシンプルにされ、意図的に組み立てられた知識の表現
- 情報の持つ意味を明らかにし、その情報を問題に集中させる

---

## ドメイン駆動設計におけるモデルの有用性

- モデルと設計の核心が相互に形成し合う
    - ドメイン <=> モデル <=> 実装 が深く結びつくことで、モデルの更新が成果物(ソフトウェア)へ反映される
    - モデルの理解に基づいてコードを解釈でき、保守運用に役立つ

- モデルは、チームメンバー全員が使用する**言語の基盤**
    - 開発者は通訳せずにドメインエキスパートとコミュニケーションができる
    - 生まれながらの言語能力を用いてモデルの改良が可能

- モデルとは**蒸留された知識**である
    - モデルはドメイン内の最も関心のある要素を区別するための、チーム内で取り決めた方法
    - 用語を選択し、概念を分解して関連づける際に、ドメインについてどう考えることにしたかということが１つのモデルによって捉える事ができる

=> 1-3章でモデルによるこれらの貢献の意味と価値や、観点がどう絡み合っていくかを説明していく

---

## ソフトウェアの核心

ソフトウェアの核心とは、ドメインに関係した問題をユーザのために解決する能力である

ドメインに関する作業は面倒な上に、入り組んだ新しい知識を大量に必要とするが、そうした知識は技術者の能力を向上させるものだと思われない

技術者は複雑なフレームワークに取り組み、技術によってドメインの問題を解決しようとしたりする

ソフトウェアの核心に真正面から立ち向かわなければ、的外れなソフトウェアを作ってしまう危険がある

---
## 第1章 知識を噛み砕く

- プリント基板設計用の専門ソフトウェアツールの設計で行われた会話の例
- ドメインエキスパートと開発者が会話を通してモデルを作り上げる
- 初期のモデルをプロトタイプに落とし、ドメインエキスパートに示すことでモデルがソフトウェアにどう関係するのかを理解させることができた
- モデルを改良すると、コードも一緒に進化し、機能の豊富なツールを手に入れることができた

---
### 効果的なモデリングの要素

- モデルと実装を結び付ける
    - プロトタイピングによって本質的な結びつきが早い時期に作り出され、それが以後のイテレーションを通してずっと維持された
- モデルに基づいて言語を洗練させる
    - プロジェクトが進むにつれてモデルから用語を**そのまま取り出し**モデルの構造と矛盾しない文章にまとめて、通訳しなくても正確に理解し合えるようになった
- 知識豊富なモデルを開発する
    - **モデルとは単なるデータスキーマではない**
    - モデルは様々な種類の知識(ドメインの)が含まれている
- モデルを蒸留する
    - モデルが完成するに連れて**重要な概念が追加され、不要な概念が取り除かれていく**
    - 不要な概念と必要な概念が結びついてる時は本質的な概念を切り分け、不要なものを削除した新たなモデルを探す
- ブレインストーミングと実験を行う
    - 言語・スケッチ・ブレストを組み合わせることで、議論の場がモデルの実験室に変わる
    - 表現が明確でわかりやすいか、それともぎこちないかを聞いて察知することができる

これらを行うことで**知識の噛み砕き**が行われ、知識を価値のあるモデルへ変えることが出来る

---
### 知識の噛み砕き

有能なドメインモデラは知識を噛み砕く
- 大部分の意味を理解できるシンプルな見方を見つけようとする
- 多くのモデルが試され、却下され、変更され蒸留されていく

知識の噛み砕きはチームが共同で行う作業
- 様々な情報(ドキュメント・話し合い...etc)を噛み砕、役に立つ形にする

実装からのフィードバック
- 初期バージョン・プロトタイプの経験による**フィードバックにより解釈が変わっていく**
- 一方向ではなく、実装からのフィードバックがあるというのが**重要**
- ウォータフォールのような旧来手法ではモデルがうまく機能しない一因は実装からのフィードバックがないから

チームメンバーによる知識の噛み砕き
- ドメインモデルを改良し続けることで開発者はドメインの原理を習得するように強いられる
- ドメインエキスパートは蒸留して本質を抽出するように強いられる

知識の噛み砕きを通して作られたモデル
- ビジネスに関する深い知識が反映されている
- モデルは綺麗に構成され、抽象化され実装に役立つ

モデルは情報を体系化するためのツール
- モデルは要件を分析することに焦点を合わせているがプログラミングや設計と深く相互作用する
- モデルの理解を通してドメインに対する洞察が深まり、モデルがさらに精緻化される

---
### 継続的学習

知識の断片化
- プロジェクトの知識は多くの人やドキュメントの間に散財し、どの知識が本当に必要なのかもわからない
- 典型的なアプローチではコードやドキュメントは**知識**を伝えないため人の移動により知識は失われる

継続的学習の実践
- 自分達の知識を意識的に育てて、継続的学習を実施する
- ドメインモデリングのスキルや技術的な知識の向上を行いつつも、取り組んでいるドメインについて真剣に学習する

[TODO]継続的学習

---
### 知識豊富な設計

モデルによって捉えらえる知識
- ドメインに現れる名詞(エンティティ)を見つけることだけではない
- ビジネスの活動やルールも含まれている

モデルの変化
- 変化したモデルを表現するように実装をリファクタリング
- 新しい知識をアプリケーションで利用できるようになる

---
#### 予約アプリケーションの例

ある船の一回の航海に対して、貨物を運んでもらうように予約するアプリケーション
- 貨物(Cargo)を航海(Voyage)と関連づけ、その関係を記録し追跡する責務を負う

```
    [航海] --------* [貨物]
```

```
public int makeBooking(Cargo cargo, Voyage voyage) {
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

輸送業界で標準的な慣習としてある「オーバーブッキング」(船舶が運搬できる量より多く貨物を受け付ける)をアプリケーションで扱えるようにする。

```
    10%のオーバーブッキングを認める
```

```
    |-----|           |-----|
    | 航海 | --------* | 貨物 |
    |-----|           |-----|
    |積載量|           |サイズ|
    |-----|           |-----|
```

```
public int makeBooking(Cargo cargo, Voyage voyage) {

    //-------------------------added---------------------------
    // 最大予約 = 航海の積載量 x 1.1
    double maxBooking = voyage.capacity() * 1.1
    if ((voyage.bookedCargoSize() + cargo.size()) > maxBooking)
        return -1;
    //---------------------------------------------------------
    
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

- ビジネスエキスパートがコードを読んで、ルールが正しいかどうかを検証できない
- ビジネスについて知らない技術者が要求定義書の記述をコードと結びつけることが困難

知識をより適切に捉えられる設計に変更する
- オーバーブッキングというルールをポリシーと捉える
- ストラテジーと呼ばれるデザインパターンを適用しポリシーという概念を明確に表現する


```
    |-----|           |-----|
    | 航海 | --------* | 貨物 |
    |-----|     ^     |-----|
    |積載量|     |     |サイズ|
    |-----|     |     |-----|
    　　　　　　　｜
    　　　　　　　｜
    　　　　　　　｜
    　　　　　　　｜
    　[オーバーブッキングポリシー]
```

```
public int makeBooking(Cargo cargo, Voyage voyage) {

    //-------------------------modified---------------------------
    if (!overbookingPolicy.isAllowed(cargo, voyage)) return -1;
    //---------------------------------------------------------
    
    int confirmation = orderConfirmationSequence.next();
    voyage.addCargo(cargo, confirmation);
    return confirmation;
}
```

オーバーブッキングポリシーのメソッド
```
public boolean isAllowed(Cargo cargo, Voyage voyage) {
    return (cargo.size() + voyage.bookedCargoSize()) <= (voyage.capacity()* 1.1);
}
```

オーバーブッキングというポリシーが存在することが明確

※ **こうした手の込んだ設計をドメインのあらゆる詳細に適用することを推奨してるわけではない**

明示的な設計の利点
- 誰もがオーバーブッキングの本質を明確で重要なビジネスルールだと理解する
- 成果物をドメインエキスパートが理解でき、フィードバックループを作ることができる

---
### 深いモデル

有用で明確なモデル
- 役立つモデルはすぐに見つかることは滅多にない
- 多くの場合は重要と思われたモデル要素を廃棄したり違った視点で見ることで問題の核心をつくような、うまい抽象が現れてくる
- ドメインの理解やモデリングテクニックの洗練が求められる
